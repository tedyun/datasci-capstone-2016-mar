#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
if (length(idx) > 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
matTrained <- matrix(NA, nrow = 100, ncol = 4)
matTrained <- trainMatrix(matTrained, newsTokenized[1:1000], wordToIndexDict)
saveRDS(matTrained, "matTrained1000.rds")
head(matTrained)
tail(matTrained)
saveRDS(matTrained, "matTrained1000.rds")
wordToIndexDict[["case"]]
wordToIndexDict[["of"]]
matTrained[matTrained[,1] == 1360 & matTrained[,2] == 16,]
which(matTrained[,1] == 1360 & matTrained[,2] == 16, arr.ind = TRUE)
complete.cases(matTrained[matTrained[,1] == 1360 & matTrained[,2] == 16,])
matTrained[!is.na(matTrained[,1]) & matTrained[,1] == 1360 & matTrained[,2] == 16,]
dim(matTrained)
saveRDS(matTrained, "matTrainednews1000.rds")
matTrained <- trainMatrix(matTrained, newsTokenized[1001:2000], wordToIndexDict)
matTrained <- readRDS("matTrainednews1000.rds")
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow, 1])) {
break
}
}
print(paste("Starting at", curRow, "th row"))
for (i in 1:length(listTokenized)) {
if (i %% 100 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
if (length(idx) > 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
rm(blogs)
rm(twitter)
rm(news)
matTrained <- trainMatrix(matTrained, newsTokenized[1001:2000], wordToIndexDict)
saveRDS(matTrained, "matTrained_news2000.rds")
mat
mat[,3:4]
mat[,4]
predict <- function (mat, sWord1, sWord2, indexToWordVect) {
sub <- mat[which(mat[,1] == sWord1 & mat[,2] == sWord2, arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(-sub[,4]),]
sub
}
predict(matTrained, "case", "of", indexToWordVect)
predict <- function (mat, sWord1, sWord2, indexToWordVect) {
sub <- mat[which(mat[,1] == sWord1 & mat[,2] == sWord2, arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub
}
predict(matTrained, "case", "of", indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub
}
predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x <- predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x[2]
x[1]
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub
}
x <- predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
sub
}
x <- predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
print(sub)
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
print(sub)
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
print(sub)
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
print(sub)
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(-sub[2]),]
print(sub)
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
matTrained <- readRDS("matTrained_news2000.rds")
growRow <- function (mat) {
rowN <- nrow(mat)
colN <- ncol(mat)
mat2 <- matrix(NA, nrow=rowN, ncol=colN)
return(rbind(mat, mat2))
}
isString <- function (sWord) {
return(!is.na(sWord) && length(sWord) > 0 && nchar(sWord) > 0)
}
findRow3 <- function (mat, row, curRow) {
found <- FALSE
limit <- min(curRow, nrow(mat))
for (idx in 1:limit) {
if (identical(mat[idx,][1:3], row)) {
found <- TRUE
break
}
}
if (found) {
return(idx)
} else {
return(-1)
}
}
# 4*N matrix
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow, 1])) {
break
}
}
print(paste("Starting at", curRow, "th row"))
for (i in 1:length(listTokenized)) {
if (i %% 100 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
if (length(idx) > 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(-sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
newsTokenized <- readRDS("newsTokenized.rds")
wordToIndexDict <- readRDS("wordToIndexDict.rds")
indexToWordVect <- readRDS("indexToWordVect.rds")
matTrained <- readRDS("matTrained_news2000.rds")
library(hash)
matTrained <- trainMatrix(matTrained, newsTokenized[2001:5000], wordToIndexDict)
matTrained <- readRDS("matTrained_news2000.rds")
matTrained <- trainMatrix(matTrained, newsTokenized[2001:3000], wordToIndexDict)
paste("", 3, "_", 4)
paste(3, 4)
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow, 1])) {
break
}
}
print(paste("Starting at", curRow, "th row"))
print("Building index..")
hashIndex <- hash()
for (i in 1:(curRow - 1)) {
key <- paste(mat[i, 1], mat[i, 2], mat[i, 3])
hashIndex[[key]] <- i
}
print("Index built.")
for (i in 1:length(listTokenized)) {
if (i %% 100 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
## idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
hashkey <- paste(n1, n2, n3)
idx <- hashIndex[[hashkey]]
if (!is.null(idx)) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
hashIndex[[hashkey]] <- curRow
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
matTrained <- readRDS("matTrained_news2000.rds")
matTrained <- trainMatrix(matTrained, newsTokenized[2001:3000], wordToIndexDict)
saveRDS(matTrained, "matTrained_news3000.rds")
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(-sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "couple", "of", wordToIndexDict, indexToWordVect)
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow, 1])) {
break
}
}
print(paste("Starting at", curRow, "th row"))
print("Building index..")
hashIndex <- hash()
for (i in 1:(curRow - 1)) {
key <- paste(mat[i, 1], mat[i, 2], mat[i, 3])
hashIndex[[key]] <- i
}
print("Index built.")
for (i in 1:length(listTokenized)) {
if (i %% 1000 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
## idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
hashkey <- paste(n1, n2, n3)
idx <- hashIndex[[hashkey]]
if (!is.null(idx)) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
hashIndex[[hashkey]] <- curRow
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
matTrained <- trainMatrix(matTrained, newsTokenized[3001:10000], wordToIndexDict)
saveRDS(matTrained, "matTrained_news10000.rds")
matTrained <- trainMatrix(matTrained, newsTokenized[10001:20000], wordToIndexDict)
saveRDS(matTrained, "matTrained_news20000.rds")
predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
predict(matTrained, "mean", "the", wordToIndexDict, indexToWordVect)
predict(matTrained, "me", "the", wordToIndexDict, indexToWordVect)
matTrained <- trainMatrix(matTrained, newsTokenized[20001:30000], wordToIndexDict)
saveRDS(matTrained, "matTrained_news30000.rds")
