if (identical(mat[idx,][1:3], row)) {
found <- TRUE
break
}
}
if (found) {
return(idx)
} else {
return(-1)
}
}
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow][1])) {
break
}
}
for (i in 1:length(listTokenized)) {
if (i %% 100 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
idx <- findRow3(mat, c(n1, n2, n3), curRow)
if (idx >= 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
matTrained <- matrix(NA, nrow = 100, ncol = 4)
matTrained <- trainMatrix(matTrained, newsTokenized, wordToIndexDict)
newsTokenized[[1:2]]
newsTokenized[[1]]
newsTokenized[1:3
]
newsTokenized[1:2]
matTrained <- matrix(NA, nrow = 100, ncol = 4)
matTrained <- trainMatrix(matTrained, newsTokenized[1:100], wordToIndexDict)
head(matTrained)
matTrained[matTrained[,4] > 1,]
head(matTrained[matTrained[,4] > 1,])
indexToWordVect[89]
indexToWordVect[46]
indexToWordVect[90]
indexToWordVect[142]
indexToWordVect[6]
indexToWordVect[143]
mat
mat[ mat[,1] == 1 & m[,2] == 3 , ]
mat[ mat[,1] == 1 & mat[,2] == 3 , ]
mat[ !is.na(mat[,1]) & mat[,1] == 1 & mat[,2] == 3 , ]
mat[ !is.na(mat[,1]) & mat[,1] == 1 & mat[,2] == 4 , ]
length(mat[ !is.na(mat[,1]) & mat[,1] == 1 & mat[,2] == 4 , ])
length(mat[ !is.na(mat[,1]) & mat[,1] == 1 & mat[,2] == 4 , ])
length(mat[ !is.na(mat[,1]) & mat[,1] == 1 & mat[,2] == 3 , ])
which(mat[ !is.na(mat[,1]) & mat[,1] == 1 & mat[,2] == 3 , ])
which(mat[,1]==1 & mat[,2] == 3, arr.ind = TRUE)
which(!is.na(mat[,1]) & mat[,1]==1 & mat[,2] == 3, arr.ind = TRUE)
which(mat[,1]==1 & mat[,2] == 2, arr.ind = TRUE)
which(mat[,1]==1 & mat[,2] == 3, arr.ind = TRUE)
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow][1])) {
break
}
}
for (i in 1:length(listTokenized)) {
if (i %% 100 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
if (length(idx) > 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
matTrained <- matrix(NA, nrow = 100, ncol = 4)
matTrained <- trainMatrix(matTrained, newsTokenized[1:100], wordToIndexDict)
head(matTrained)
tail(matTrained)
matTrained <- matrix(NA, nrow = 100, ncol = 4)
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow][1])) {
break
}
}
for (i in 1:length(listTokenized)) {
if (i %% 1000 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
if (length(idx) > 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
matTrained <- trainMatrix(matTrained, newsTokenized, wordToIndexDict)
matTrained <- matrix(NA, nrow = 100, ncol = 4)
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow][1])) {
break
}
}
print(paste("Starting at", curRow, "th row"))
for (i in 1:length(listTokenized)) {
if (i %% 1000 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
if (length(idx) > 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
matTrained <- matrix(NA, nrow = 100, ncol = 4)
matTrained <- trainMatrix(matTrained, newsTokenized[1:1000], wordToIndexDict)
saveRDS(matTrained, "matTrained1000.rds")
head(matTrained)
tail(matTrained)
saveRDS(matTrained, "matTrained1000.rds")
wordToIndexDict[["case"]]
wordToIndexDict[["of"]]
matTrained[matTrained[,1] == 1360 & matTrained[,2] == 16,]
which(matTrained[,1] == 1360 & matTrained[,2] == 16, arr.ind = TRUE)
complete.cases(matTrained[matTrained[,1] == 1360 & matTrained[,2] == 16,])
matTrained[!is.na(matTrained[,1]) & matTrained[,1] == 1360 & matTrained[,2] == 16,]
dim(matTrained)
saveRDS(matTrained, "matTrainednews1000.rds")
matTrained <- trainMatrix(matTrained, newsTokenized[1001:2000], wordToIndexDict)
matTrained <- readRDS("matTrainednews1000.rds")
trainMatrix <- function (mat, listTokenized, wordToIndexDict) {
# find the current row
for (curRow in 1:nrow(mat)) {
if (is.na(mat[curRow, 1])) {
break
}
}
print(paste("Starting at", curRow, "th row"))
for (i in 1:length(listTokenized)) {
if (i %% 100 == 0) {
print (paste(i, "-th line trained."))
}
sublist <- listTokenized[[i]]
for (j in 1:length(sublist)) {
sVec <- sublist[[j]]
if (length(sVec) < 3) {
next
}
for (k in 1:(length(sVec) - 2)){
sWord1 <- sVec[k]
sWord2 <- sVec[k + 1]
sWord3 <- sVec[k + 2]
if (isString(sWord1) && isString(sWord2) && isString(sWord3)) {
n1 <- wordToIndexDict[[tolower(sWord1)]]
n2 <- wordToIndexDict[[tolower(sWord2)]]
n3 <- wordToIndexDict[[tolower(sWord3)]]
## print(paste(sWord1, sWord2, sWord3))
if (!is.null(n1) && !is.null(n2) && !is.null(n3)) {
## find the row
#             found <- FALSE
#             for (idx in 1:nrow(mat)) {
#               if (identical(mat[idx,][1:3], row)) {
#                 found <- TRUE
#                 break
#               }
#             }
#             if (!found) {
#               idx <- -1
#             }
## idx <- findRow3(mat, c(n1, n2, n3), curRow)
idx <- which(mat[,1]==n1 & mat[,2] == n2 & mat[,3] == n3, arr.ind = TRUE)
if (length(idx) > 0) {
mat[idx, 4] <- mat[idx, 4] + 1
} else {
if (curRow > nrow(mat)){
print("Growing matrix..")
rowN <- nrow(mat)
colN <- ncol(mat)
mat <- rbind(mat, matrix(NA, nrow=rowN, ncol=colN))
print(paste("Matrix grown.", nrow(mat)))
}
# Growing 1 row
mat[curRow,] <- c(n1, n2, n3, 1)
curRow <- curRow + 1
}
}
}
}
}
}
mat
}
rm(blogs)
rm(twitter)
rm(news)
matTrained <- trainMatrix(matTrained, newsTokenized[1001:2000], wordToIndexDict)
saveRDS(matTrained, "matTrained_news2000.rds")
mat
mat[,3:4]
mat[,4]
predict <- function (mat, sWord1, sWord2, indexToWordVect) {
sub <- mat[which(mat[,1] == sWord1 & mat[,2] == sWord2, arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(-sub[,4]),]
sub
}
predict(matTrained, "case", "of", indexToWordVect)
predict <- function (mat, sWord1, sWord2, indexToWordVect) {
sub <- mat[which(mat[,1] == sWord1 & mat[,2] == sWord2, arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub
}
predict(matTrained, "case", "of", indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub
}
predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x <- predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x[2]
x[1]
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub
}
x <- predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
sub
}
x <- predict(matTrained, "case", "of", wordToIndexDict, indexToWordVect)
x
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
print(sub)
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2])]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
print(sub)
if (nrow(sub) > 0) {
sub <- data.frame(sub[,3:4])
sub <- sub[order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "that", "is", wordToIndexDict, indexToWordVect)
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
print(sub)
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[-order(sub[2]),]
print(sub)
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
predict <- function (mat, sWord1, sWord2, wordToIndexDict, indexToWordVect) {
sub <- mat[which(mat[,1] == wordToIndexDict[[sWord1]] & mat[,2] == wordToIndexDict[[sWord2]], arr.ind=TRUE),]
sub <- data.frame(sub[,3:4])
sub <- sub[order(-sub[2]),]
print(sub)
sub[1] <- sapply(sub[1], function (idx) { indexToWordVect[idx] }, USE.NAMES = FALSE)
return(sub)
}
predict(matTrained, "i", "am", wordToIndexDict, indexToWordVect)
